#!/usr/bin/perl
# $Header$
use Getopt::Std;

  $rcsid = q$Id: hasida-table,v 0.8 2013/12/15 makoto Exp $;
#------------ com_leaf for appropriate help message ----
# command name, strip all before '/' inclusively
# /home/fujiwara/perl/com_path-test -> com_path-test
$my_leaf = $0;
$my_leaf =~ s#(.*)/##;
#------------ com_path for getting right @INC path -----
# command location, strip rightmost '/' and right of it.
# /home/fujiwara/perl/com_path-test -> /home/fujiwara/perl
$my_path = $0;
$my_path =~ s|/[^/]+$||;
#---------------------
push(@INC,$my_path);
our %opts;

# --- one char parameters --- SEE bottom for explanation
$right          =  5    ; # logical difference left to right ( integer )
# --- graphics parm for one char ---
$linewidth      =  0.05 ; # line width for dot/white/double ( in pt = 1/72 inch )
$unit           =  2.9  ; # minimum pitch of grid ( in pt )
# 
$kanjiOffset    =  4    ; # stroke graphics to Kanji location ( in unit ) 
$rightoffset    =  5    ; # distance of right/left for print  ( in unit )
                          # actual = $right + $rightoffset
$nextChar       = 15.5  ; # offset to next char    ( in unit, can be fraction )

$frameheight    = 16 ;       # in pt
$framewidth     = 15.5 * $unit ; # in pt
$framelinewidth = 0.01 ;  # in pt 1/4 is minimum for 300dpi
$dot            = 0.3  ;  # dot size for grid ( in pt )

# --- page layout related --
$linePitch      = 1.00  ; # line pitch ( in bodyfontsize )
$linesPerColumn = 51   ; # vertical char count

$linesPerColumn--;

getopts('bdf:g:hHjn:ors:t', \%opts);  # command line argument
my ($aiueo) = 'aiueo-full-1351.jis';

# ----------------- help -------------
if ( $opts{'h'} ) {  &usage ; }
if ( $opts{'j'} ) {  &usagej ; }

if ( $opts{'g'} ) { $dot = $opts{'g'} }
# -----------------------------------

if ( $opts{'s'} ) { $STROKE = $opts{'s'} }
else          { $STROKE = './tcode.st'; }
#else          { $STROKE = $ENV{'HOME'}.'/tcode/tc.el/tcode.st'; }

if ( $opts{'H'} ) {
    $opts{'b'}++ ; $opts{'r'}++ ; $opts{'o'}++ ;
    $opts{'f'}   = '/dev/null';
    $opts{'s'}   = './tcode.st';
    $aiueo = 'aiueo-hasida-1215.jis' ;
}

open(STROKE) || die "Problem opening stroke table: $STROKE: $!\n";

if ( $#ARGV > -1 ) { 
    open(STDIN,"$ARGV[0]")  || die "Problem opening $ARGV[0]: $!\n";
} else {
    open(STDIN, "$aiueo" )  || die "Problem opening $aiueo: $!\n";
}
# --------------------------------------------------
# read negative file
# --------------------------------------------------
our @negative = split ',',$opts{'n'};
if ( $opts{'n'} )  {
    my @negative = split ',',$opts{'n'};
    foreach my $n (@negative) {
    open(NEGATIVE,"$n") || die "Problem opening negative file $n: $!\n";
    while(<NEGATIVE>) {
	&removeESC ;
	if ( /^$/ ) { next ; }
	chop;
	$linelen = length($_) ;
	$linelen -= 2 ;             # for foreach
	# read input file and assume each 2 bytes code aligned even byte boundary
	foreach $i ( 0..$linelen/2 ) {   
	    $char = substr($_, $i*2, 2 );
	$negative{"$char"}++;       # store in hashtable
#	print STDERR "\033\$B",$char,"\033(B";
	}
    }
    close(NEGATIVE);
    } # end foreach
#    print STDERR "\n";
}
# --------------------------------------------------
#  read frame file and store char in @frame 
# --------------------------------------------------
if ( $opts{'f'} ) {
    open(FRAME,"$opts{'f'}") || die "Problem opening Frame file $opts{'f'}:$!\n";
    while(<FRAME>) {
	&removeESC ;
	if ( /^$/ ) { next ; }
	chop;
	$linelen = length($_) ;
	$linelen -= 2 ;             # for foreach
	# read  input file and assume each 2 bytes code aligned even byte boundary
	foreach $i ( 0..$linelen/2 ) {   
	    $char = substr($_, $i*2, 2 );
    if ( $char =~ /\\/ ) { $char =~ s/\\/\\\\/ }
    if ( $char =~ /\)/ ) { $char =~ s/\)/\\\)/ }
    if ( $char =~ /\(/ ) { $char =~ s/\(/\\\(/ }

	$frame{"$char"}++;
#	print STDERR "\033\$B",$char,"\033(B";
	}
    }
    close(FRAME);
    
}
# ----------------------------------------------------
# read prolog generated by a2ps attached after __END__
# ----------------------------------------------------
if ( !$opts{'d'} ) {
    while(<DATA>) {
	if ( /^ENDPSENDPS/ ) { last }
	else { print ; }
    }
}
&prolog ; # local modifications for prolog ( after a2ps code )
# ----------------------------------------------------
# read stroke table and 
# put it @lines ( array of tcode.st line ) and
#        @offset shows LL or LR or RL or RR
#        Assume those two arrays has the same index to correlate.
# ----------------------------------------------------
while (<STROKE>) { 
    if    ( /^$/     ) {  next ; }
    elsif ( /^\s*LL/ ) { $ttx = 0; $tty = 0; $tfx = 0; $tfy = 0 }
    elsif ( /^\s*LR/ ) { $ttx = 0; $tty = 0; $tfx = 5; $tfy = 0 }
    elsif ( /^\s*RL/ ) { $ttx = 5; $tty = 0; $tfx = 0; $tfy = 0 }
    elsif ( /^\s*RR/ ) { $ttx = 5; $tty = 0; $tfx = 5; $tfy = 0 }
    else  {
	&removeESC ;
        s/  //g;
	# put them in two arrays with the same index
        # line and associated table name = offset
        push(@lines, $_);
        push(@offset,join(':',($ttx,$tty,$tfx,$tfy)));
    }
}
# ----------------------------------------------------
# generate hash table $hash{$char} = 6:1:8:1 indicating (6,1) ->(8,1) stroke
# ----------------------------------------------------
foreach $corner ( 0 .. 3 ) {
    foreach $forestY ( reverse 0 .. 3 ) {
        foreach $treeY ( reverse 0 .. 3 ) {
            $_   = $lines[$pointer] ;
            $off = $offset[$pointer++];
            ($ttx,$tty,$tfx,$tfy) = split(':',$off);
            foreach $forestX ( 0 ..4 ) {
                foreach $treeX  ( 0 ..4 ) {
                    $column = $treeX * 2 + $forestX * 10 ;
                    $char   = substr($_,$column,2);
                    # hankaku -- zenkaku conversion ----
		    if    ( $char =~ /\d / ) { $char =~ s/(\d) /#1/;} # 1 byte number to 2bytes number)
                    elsif ( $char =~ /\? / ) { $char = '!)' ;}
                    elsif ( $char =~ /! / )  { $char = '!*' ;}
                    elsif ( $char =~ /\( / ) { $char = '!J' ;}
                    elsif ( $char =~ /\) / ) { $char = '!K' ;}
                    elsif ( $char =~ /% / )  { $char = '!s' ;}
                    $hash{$char} = join(':', ($treeX + $ttx, $treeY + $tty, $forestX + $tfx, $forestY + $tfy ))
                    }
            }
        }
    }    
}
# above $char conversion is based on following pairs
#  ？ 2129 !)
#  ！ 212a !*
#  〜 2141 !a  # this is OK
#  （ 214a !J
#  ） 214b !K
#  ％ 2173 !s

# ---------- start printing PostScript file --------
    $page = 1 ;
    &startPage ;
$pcolumn = 0 ;
$columnside = 0 ;
while (<STDIN>) {
    chop;
    &removeESC ;
    $linelen = length($_) ;
    $linelen -= 2 ;             # for foreach
    # read standard input and assume each 2 bytes code aligned even byte boundary
#    $frame = 0 ;
    foreach $i ( 0..$linelen/2 ) {   
        $char = substr($_, $i*2, 2 );

        # mark as frame is requested ( but not necessarily print -- say, negative )
	if ($opts{'f'} ) { if ( $frame{$char} ) { $frame++ } # else { $frame = 0 }}
		   }
	elsif ( $i == 0 ) { $frame++ } # enable on the 1st char on line

	if ( $negative{"$char"} > 0 ) { 
#	    print STDERR "\033\$B",$char,"\033(B";
	    $negativecount++; 
	    next ;
	} # skip char in negative list
	@stroke = split(':',$hash{$char});
	$count++;
	if ( $opts{'d'} ) {   # debug mode just generates $char -> stroke relation
	    print $char,' ',$hash{$char},"\n";
	}
	else { 
	    &oneChar($char,(@stroke),$frame); 
	    $frame = 0 ; # in any case, frame is put, not necessary for succeeding one
#	    &oneChar($char,(@stroke),0);
	    $pcolumn++;
	    if ( $pcolumn > 5 ) { 
		$pcolumn = 0 ;
		$line++ ; if ( $line > $linesPerColumn ) { 
                    $line = 0 ;
       		    if ( $columnside == 0 ) {   # next is right half of page
print <<HALF; # following grestor is to get upper left origin to move horizontally
grestore 
nextcolumn
bl % for next line
HALF
                     $columnside++;
}
		    else {   # next page
			$columnside = 0 ;
	print <<NEWPAGE ;
grestore
showpage
NEWPAGE
			&startPage ;
		    }
		} # end if ( $line > 5 )
		else {
		print "nl\nbl "; # just next line
	    }
	    }
	}
    }
}

if ($opts{'t'}) {
    statistics();
}
print_oneline("$negativecount char omitted.") if ( $opts{'n'} );
print_oneline("$count char printed.");
print <<ENDEND;
endpage

%%Trailer
cleanup
docsave restore end
ENDEND
    print STDERR "$negativecount char omitted\n" if ( $opts{'n'} );
    print STDERR "$count char printed\n";
 exit;
# -----------------------------------------------
sub startPage  {
    print "/sheet $page def\n";
    print "%%Page: $page $page\n";
    print "$page startpage\n";
    print "gsave gsave gsave % page/column/line respectively\n";
    $page++;

}
# -----------------------------------------------
sub removeESC {
        s/\033\$\@//g;
        s/\033\$B//g;
        s/\033\(J//g;
        s/\033\(B//g;
}
sub usage {
    print <<HELPHELP;
$my_leaf: 
Synonyms:
    $my_leaf [options] [aiuoe_file]
Where: 
      ( N ) indicates not implemented feature
      The options can be any combination of following.
      Options of one char may be said in merged manner,
      like -cv or -bo etc. 
      But -f, -n, -s needs one more argument.
  -c   check only ( N )
  -b   disable 'Use bold font for RL stroke'
  -d   debug mode
  -f frame_list
       add frame on the Kanji listed in this file.
       (default: add frame on the 1st char on each line )
  -g   dot size for grid in unit ( default $dot )
  -h   show usage ( This output )
  -H hasida mode, equivalent to -b -r -o -f /dev/null aiueo-1215.jis
  -j   show usage in Japanese
  -n negative_file ( omitting list multiple files maybe specifed with
     comma separated list (avoid using shell expansion), default: none).
  -o   disable 'No grid for odd side ( not used hand )'
       => get full grid anyway
  -r   reverse, circle -> filled ( default: filled -> circle )
  -v   verbose ( valid only with -c  ( N ) )
  -s stroke_table 
       is the same file as tc-mule.el reads ( tcode.st )
  -t   print statistics and command line
  aiueo_file         is the name of file which has string of
  kanji to be appeared in table  (default: read from ./$aiueo)
Note:
  All the Kanji code are expected in JIScode ( ISO-1022-JP ).
  Sequece of chars in file negative, frame can be any order.
  It doesn't matter. The sequece of aiueo_file matters.
Example:   
     ( for full 1351 list )
  $my_leaf -f frame.jis | lpr
  $my_leaf -f frame.jis $aiueo | lpr
     ( put frame, and remove some chars in negative list )
  $my_leaf -f frame.jis -n negative aiueo-full-1351.jis | lpr
     ( for original hasida table, and circle -> filled
  $my_leaf -r aiueo-hasida-1215.jis | lpr
version: $rcsid
HELPHELP
    exit;

}
sub usagej {
    print <<HELPHELP;
$my_leaf: 
Synonyms:
    $my_leaf [指定] [aiueo_file]
Where: 
      ( N ) は未実装を示す。[指定]は次のものをどのような
      順で指定しても良い。-cv -bo などと出来る。-f -n など
      はその直後に引数を一つ必要とする。
 [指定]
  -c  調べるだけ ( N )
  -b  「RL の時太字にする」を無効とする ( bold )
  -d  動作の確認用 debug mode
  -f frame_list
      frame_list で指定された譜に書いてある文字に枠を付ける
      その文字が negative で出力されないようになっていてしかもそ
      の字が aiueo_file にあれば、その後に出て来る最初の字に付ける
      この -f の指定がない時は、aiueo_file の行頭の字に枠を付ける
      何も枠を付けたくない時は -f /dev/null とすれば良い。
  -g  格子点の大きさを pt ( 1/72 inch ) で指定する。(無指定時 $dot )
  -h  使い方(英語)
  -H   見なれた元祖橋田表を印刷する。classic mode とも言う。次のものと
      等価 -b -r -o -f /dev/null aiueo-1215.jis
  -j  使い方(日本語)
  -n  negative
      印刷しない文字が書いてある譜の指定。決して使わない字や、覚えてし
      まった字を書いておくとそれを表に出さない。カンマでつないで複数も可
  -o  RR,LL の場合、使わない側の格子を印刷する(無指定では印刷しない)
  -r  反転形式。○→● ( 無指定時 ●→○)
  -v  おしゃべり形式 ( -c と供に指定の時だけ有効) (N)
  -s  名前
      打鍵表の指定 tc-mule.el が読む tcode.st を指定する
      ( Unix path の形式で指定 ) 無指定時: ./tcode.st 
  -t  処理時刻などを Postscript 内にも印刷する
  [aiueo_file]
      印刷したい漢字の一覧が書いてある譜を指定する。
      無指定時: ./$aiueo から読む
Note:
  ここで用いる漢字の譜は全ていわゆる JIScode ( ISO-1022-JP )であること。
  aiueo_file はその中に書いてある順に印刷する。また当然 tcode.st もその
  順序が重要であるが、-n, -f で指定する、省略文字と枠を付ける文字の指定
  は順序は構わない。
  (ただし信じられないことにこの Perl 手続きは *euc-japan* で保存のこと。)
Example:   
   tcode で普通に打てる 1351 全てを印刷する。(三頁になる)
  $my_leaf -f frame.jis aiueo-full-1351.jis | lpr

   negative という名前の譜の中に印刷しない(省略する)字を書いておく
  $my_leaf -f frame.jis -n negative-sample aiueo-full-1351.jis | lpr

   もともとの橋田表と同じ字種だけを印刷し、しかも○→●という順序を使う。
  $my_leaf -r aiueo-hasida-1215.jis | lpr
version: $rcsid
HELPHELP
    exit;

}

# ------------------------------------------------------
# draw one char
# ------------------------------------------------------
# kanji value is 7bit + 7bit string, example fuji(藤) = F#
# ------------------------------------------------------
# calling sequence is &oneChar('F#',8,1,6,1,frame_or_not ) 
sub oneChar {
    local($kanji)  = $_[0];
    local($blackx,$blacky,$whitex,$whitey);

    if ( $opts{'r'} ) {
	$blackx = $_[3];
	$blacky = $_[4];
	$whitex = $_[1];
	$whitey = $_[2];
    }
    else {
	$blackx = $_[1];
	$blacky = $_[2];
	$whitex = $_[3];
	$whitey = $_[4];
    }
    local($frame) = $_[5];
    local($jis)    = $kanji.' '; # force to char type
          $jis     = "\033\$B".$jis."\033(B"; #  for comment purpose
    # some escapes for kanji code 
    if ( $kanji =~ /\\/ ) { $kanji =~ s/\\/\\\\/ }
    if ( $kanji =~ /\)/ ) { $kanji =~ s/\)/\\\)/ }
    if ( $kanji =~ /\(/ ) { $kanji =~ s/\(/\\\(/ }

    $rightLeft = 0  ;
    if    ( $blackx > 4.5 && $whitex > 4.5 ) { @RL =   (1) } # right only
    elsif ( $blackx < 4.5 && $whitex < 4.5 ) { @RL = (0)   } # left  only
    else                                     {               # both
	@RL = (0,1);
	if ( $blackx > 4.5 ) { $rightLeft = 1 } 
    }
    if ( $opts{'o'} ) { @RL = (0,1) } # print R and L always as a default,
    
print <<GSAVE;
gsave
currentpoint translate
GSAVE
    if ( $frame ) {&frame }
foreach $row ( 0 .. 3 ) {
    foreach $leftright ( @RL ) {
	foreach $column ( 0 .. 4 ) {
          $x  = $column + $leftright * $right    ; # logical location ストローク位置。右なら 5 足す。
          $px = $x + $leftright * $rightoffset   ; # physical location 印刷位置への差分を足す。
          $y  = $row ;
	  if    ( $x == $blackx && $y == $blacky &&  $x == $whitex && $y == $whitey ) {
	      print "$px unit $y unit moveto double\n";
	  }
          elsif    ( $x == $blackx && $y == $blacky ) {
	      print "$px unit $y unit moveto black\n";
	  }
          elsif ( $x == $whitex && $y == $whitey ) {
	      print "$px unit $y unit moveto white\n";
	  }
          elsif ( $x != 4 && $x != 5 && $y != 3 ) { # no grid
	      print "$px unit $y unit moveto dot\n";
	  }
      }	  
    }
}      
    print "$kanjiOffset unit 0 unit moveto\n";
#    print "kanji_init " ;
    if ( ! $opts{'b'} && $rightLeft ) { print "B "; } else { print "R " }
    print "($kanji) ks % $jis\n";
    print "grestore\n";
    print "$nextChar unit 0 rmoveto    % offset\n";
} # end sub oneChar
# ----------------
sub frame {
	print <<FRAMEFRAME;
        gsave
	$framelinewidth unit setlinewidth
        0.75 unit neg 0.75 unit neg rmoveto
	0 $frameheight  rlineto
        $framewidth   0  rlineto
        0 $frameheight neg rlineto
        closepath stroke
        grestore
FRAMEFRAME
}
# ------------------------------
# prepare PostScript defines
# ------------------------------
sub prolog {
print <<PROLOG;
/unit { $unit mul } def

/mm   { 72 mul 25.4 div } def
/white {
    gsave
    currentpoint newpath 1.5 0 360 arc $linewidth setlinewidth stroke
    grestore
   } def
/black {
    gsave
    currentpoint newpath 1.5 0 360 arc fill
    grestore
   } def
/dot {
    gsave
    currentpoint newpath $dot 0 360 arc fill
    grestore
   } def
/double {
    gsave
    currentpoint newpath 1.5 0 360 arc $linewidth setlinewidth stroke
    grestore
    gsave
    currentpoint newpath 0.2 0 360 arc $linewidth setlinewidth stroke
    grestore
} def

/nl {
      grestore
      0 bodyfontsize $linePitch mul neg rmoveto
    } bind def 
/nlst {
      grestore
      0 statfontsize 1.3 mul neg rmoveto
    } bind def
/nextcolumn {
%	 upperx sheetside get  bodymargin 2 div  add sheetwidth 2 div add 
	 upperx sheetside get                        sheetwidth 2 div add 2 unit sub
	    uppery 
	    bodymargin bodyfontsize add noheader {0} {headersize} ifelse  add
	 sub
      moveto
      } def

startdoc
%%EndProlog
$linewidth setlinewidth
% -----------------
% start actual page
% -----------------
( --- Hasida  Table --) newfile
PROLOG
} 
# -----------------------------------
sub statistics(){
	my $localtime = localtime();
	print <<START_STAT;
      gsave
        statfont setfont
        cr nl
START_STAT
  print_oneline ('');
  print_oneline($localtime);
  print_oneline("$aiueo");

  if (@negative) {
      print_oneline("negative file(s):");
      foreach my $n (@negative) { print_oneline('  '.$n);}
  }
 }
 sub print_oneline($) {
  my $line = shift;
  print "bl ($line) s nlst\n";
}
# -----------------------------------

# $Log: hasida-table,v $
# Revision 1.3  1996/04/26  22:46:00  makoto
# -H added for hasida mode, change default path for -s
#
# Revision 1.2  1996/04/26  21:26:53  makoto
#    rename as hasida
#    Japanese help with -j  ->  *euc-japan* code
#    -g option for grid dot size
#    default grid dot 0.2 pt -> 0.3 pt
#    put frame on new line if -f not said
#    putting frame for any succeeding char on aiueo_file
#    ( when negative/frame struggles)
#    perl code in *euc-japan*
#    put %  in prologue and comment
#
# Revision 1.1  1996/04/26  21:24:41  makoto
# Initial revision
#
# Revision 1.13  1996/02/29  12:36:00  makoto
# -r added for white -> black
#
# Revision 1.12  1996/02/28  13:46:55  makoto
# usage updated
#
# Revision 1.11  1996/02/28  13:27:43  makoto
# move right  13pt ( /upperx hard coded as 13 pt )
#
# Revision 1.10  1996/02/28  10:57:49  makoto
# escape for frame char, uppery 5mm move down
#
# Revision 1.9  1996/02/27  12:59:55  makoto
# frame added, -b -o logic reversed, upper/lower adjusted
#
# Revision 1.8  1996/02/18  13:25:33  makoto
# -o odd_side not printed, -b bold font for RL
#
# Revision 1.7  1996/02/18  12:28:54  makoto
# -n negative added
#
# Revision 1.6  1996/02/18  02:26:48  makoto
# setlinewidth missing on double
## Revision 1.5  1996/02/17  05:30:37  makoto
# put setlinewidth in white etc, above 'type' is 'typo'
#
# Revision 1.4  1996/02/17  05:09:47  makoto
# mod the last comment
#
# Revision 1.3  1996/02/17  04:50:26  makoto
# type for linesPerColumn
#
# Revision 1.2  1996/02/17  04:47:34  makoto
# jiscode edit is not sufficient. add more for Mule output
#
# Revision 1.1  1996/02/17  02:47:31  makoto
# Initial revision
#
# Revision 1.5  1996/02/16  10:51:58  makoto
# setlinewidth,%PS-Adobe
#
# Revision 1.4  1996/02/15  14:15:24  makoto
# fix 0..9()%?! problem
#
# Revision 1.3  1996/02/14  14:34:58  makoto
# size adjust. $unit is not used
#
# Revision 1.2  1996/02/14  12:53:08  makoto
# initial version

#-------------------------------------------
# echo 藤 | a2ps -ns -p -nh -nt -nf -f16 is inserted hereafter
#-------------------------------------------
# also, smargin is changed 
__END__
%!PS-Adobe-1.0
%%Title: hasida-table
%%Creator: Id: a2ps,v 1.37 1995/03/06 11:35:35 utashiro Exp 
%%CreationDate: Mon Feb 12 20:43:04 1996
%%Pages: (atend)
%%PageOrder: Ascend
%%DocumentPaperSizes: A4
%%Orientation: Portrait
%%EndComments

/$a2psdict 100 dict def
$a2psdict begin
% Initialize page description variables.
/inch {72 mul} bind def
%% SelectTray
statusdict /a4tray known { statusdict begin a4tray end } if
/landscape false def
/twinpage false def
/sheetheight 11.64 inch def
/sheetwidth 8.27 inch def
%/lmargin 1.2 inch def
/lmargin 0 def
/smargin 0.1 inch def
/paper_adjust 0.05 inch def
/noborder true def
/noheader true def
/headersize 0.0 def
/nofooter true def
/nopunchmark true def
/bodyfontsize 16 def
/statfontsize 8 def
/kanjiAsciiRatio 1 def
/lines 41 def
/columns 52 def
/date (Feb 12 1996 20:43) def
/doasciimag false def
%!  PostScript Source Code
%
%  File: imag:/users/local/a2ps/header.ps
%  Created: Tue Nov 29 12:14:02 1988 by miguel@imag (Miguel Santana)
%  Version: 2.0
%  Description: PostScript prolog for a2ps ascii to PostScript program.
% 
%  Edit History:
%  - Original version by evan@csli (Evan Kirshenbaum).
%  - Modified by miguel@imag to:
%    1) Correct an overflow bug when printing page number 10 (operator
%	cvs).
%    2) Define two other variables (sheetwidth, sheetheight) describing
%	the physical page (by default A4 format).
%    3) Minor changes (reorganization, comments, etc).
%  - Modified by tullemans@apolloway.prl.philips.nl
%    1) Correct stack overflows with regard to operators cvs and copy.
%       The resulting substrings where in some cases not popped off 
%       the stack, what can result in a stack overflow.
%    2) Replaced copypage and erasepage by showpage. Page througput
%       degrades severely (see red book page 140) on our ps-printer
%       after printing sheet 16 (i.e. page 8) of a file which was 
%       actually bigger. For this purpose the definitions of startdoc
%       and startpage are changed.
%  - Modified by Tim Clark <T.Clark@uk.ac.warwick> to:
%    1) Print one page per sheet (portrait) as an option.
%    2) Reduce size of file name heading, if it's too big.
%    3) Save and restore PostScript state at begining/end. It now uses
%	conventional %%Page %%Trailer markers.
%    4) Print one wide page per sheet in landscape mode as an option.
%  - Modified by miguel@imag.fr to
%    1) Add new option to print n copies of a file.
%    2) Add new option to suppress heading printing.
%    3) Add new option to suppress page surrounding border printing.
%    4) Add new option to change font size. Number of lines and columns
%	are now automatically adjusted, depending on font size and
%	printing mode used.
%    5) Minor changes (best layout, usage message, etc).
%  - Modified by kanazawa@sra.co.jp to:
%    1) Handle Japanese code
%  - Modified by utashiro@sra.co.jp to:
%    1) Fix bug in printing long label
%    2) Handle carriage-return
%    3) Specify kanji-ascii character retio
%    4) Add footer label
%    5) Change filename->fname becuase ghostscript has operator filename
%    6) Support three different font style
%    7) Incorporate B4 paper support and punchmark contributed
%       by Masami Ueno <cabbage@kki.esi.yamanashi.ac.jp>
%

% Copyright (c) 1988, Miguel Santana, miguel@imag.imag.fr
%
% Permission is granted to copy and distribute this file in modified
% or unmodified form, for noncommercial use, provided (a) this copyright
% notice is preserved, (b) no attempt is made to restrict redistribution
% of this file, and (c) this file is not distributed as part of any
% collection whose redistribution is restricted by a compilation copyright.
%


% General macros.
/xdef {exch def} bind def
/getfont {exch findfont exch scalefont} bind def

% Page description variables and inch function are defined by a2ps program.

% Character size for differents fonts.
   landscape
   { /filenamefontsize 12 def }
   { /filenamefontsize 16 def }
ifelse
/datefontsize filenamefontsize 0.8 mul def
%/headermargin filenamefontsize 0.25 mul def
/headermargin filenamefontsize 0 mul def
/bodymargin bodyfontsize 0.7 mul def

% Font assignment to differents kinds of "objects"
/filenamefontname /Helvetica-Bold def
/stdfilenamefont filenamefontname filenamefontsize getfont def
/datefont /Helvetica datefontsize getfont def
/footerfont /Helvetica-Bold datefontsize getfont def
/mag { doasciimag { [ 1 0 0 asciimagsize 0 0 ] makefont } if } def
/bodynfont /Courier bodyfontsize getfont mag def
/statfont  /Courie statfontsize getfont mag def
/bodybfont /Courier-Bold bodyfontsize getfont mag def
/bodyofont /Courier-BoldOblique bodyfontsize getfont mag def
/fontarray [ statfont bodynfont bodybfont bodyofont ] def
/bodyfont bodynfont def

% Initializing kanji fonts
/kanji_initialized false def
/kanji_init {
   kanji_initialized not
   {
      /bodykfontsize bodyfontsize kanjiAsciiRatio mul def
      /bodyknfont /Ryumin-Light-H bodykfontsize getfont def
      /bodykbfont /GothicBBB-Medium-H bodykfontsize getfont def
      /bodykofont bodykbfont [ 1 0 .2 1 0 0 ] makefont def
      /KanjiRomanDiff 1.2 bodyfontsize mul 1.0 bodykfontsize mul sub def
      /KanjiRomanDiffHalf KanjiRomanDiff 2 div def
      /kfontarray [ bodyknfont bodykbfont bodykofont ] def
      /kanji_initialized true def
   } if
} def

% Backspace width
/backspacewidth
   bodyfont setfont (0) stringwidth pop
   def

% Logical page attributs (a half of a real page or sheet).
/pagewidth
   bodyfont setfont (0) stringwidth pop columns mul bodymargin dup add add
   def
/pageheight
   bodyfontsize 1.1 mul lines mul bodymargin dup add add headersize add
   def

% Coordinates for upper corner of a logical page and for sheet number.
% Coordinates depend on format mode used.
% In twinpage mode, coordinate x of upper corner is not the same for left
% and right pages: upperx is an array of two elements, indexed by sheetside.
/rightmargin smargin 3 div def
/leftmargin smargin 2 mul 3 div def
/topmargin lmargin twinpage {3} {2} ifelse div def
landscape
{  % Landscape format
   /punchx .4 inch def           % for PunchMark
   /punchy sheetwidth 2 div def  % for PunchMark
   /uppery rightmargin pageheight add bodymargin add def
   /sheetnumbery sheetwidth leftmargin pageheight add datefontsize add sub def
   twinpage
   {  % Two logical pages
      /upperx [ topmargin 2 mul			% upperx for left page
		dup topmargin add pagewidth add	% upperx for right page
	      ] def
      /sheetnumberx sheetheight topmargin 2 mul sub def
   }
   {  /upperx [ topmargin dup ] def
      /sheetnumberx sheetheight topmargin sub datefontsize sub def
   }
   ifelse
}
{  % Portrait format
   /punchx .3 inch def
   /punchy sheetheight 2 div def
   /uppery topmargin pageheight add def
   /uppery { 297.7 mm } bind def
%  /leftmargin { 4 mm } bind def
   /leftmargin { 13 } bind def
   /upperx [ leftmargin dup ] def
   /sheetnumberx sheetwidth rightmargin sub datefontsize sub def
   /sheetnumbery
	 sheetheight 
	 topmargin pageheight add datefontsize add headermargin add
      sub
      def
}
ifelse

% Strings used to make easy printing numbers
/pnum 12 string def
/empty 12 string def

% Other initializations.
datefont setfont
/datewidth date stringwidth pop def
/pagenumwidth (Page 999) stringwidth pop def
/filenameroom
         pagewidth
	 filenamefontsize 4 mul datewidth add pagenumwidth add
      sub
   def


% Function startdoc: initializes printer and global variables.
/startdoc
    { /sheetside 0 def			% sheet side that contains current page
      /sheet 1 def			% sheet number
   } bind def

% Function newfile: init file name for each new file.
/newfile
    { cleanup
      /fname xdef
      stdfilenamefont setfont
      /filenamewidth fname stringwidth pop def
      /filenamefont
	 filenamewidth filenameroom gt
	 {
	       filenamefontname
	       filenamefontsize filenameroom mul filenamewidth div
	    getfont
	 }
	 {  stdfilenamefont }
	 ifelse
	 def
    } bind def

% Function printpage: Print a physical page.
/printpage
    { /sheetside 0 def
      twinpage
      {  noborder not
	    { sheetnumber }
	 if
      }
      {  noheader noborder not and
	    { sheetnumber }
	 if
      }
      ifelse
      showpage 
%      pagesave restore
      /sheet sheet 1 add def
    } bind def

% Function cleanup: terminates printing, flushing last page if necessary.
/cleanup
    { twinpage sheetside 1 eq and
         { printpage }
      if
    } bind def

%
% Function startpage: prints page header and page border and initializes
% printing of the file lines.  Page number is stored on the top of stack.
/startpage
    { /pagenum exch def
      sheetside 0 eq
	{ % /pagesave save def
	  landscape
	    { sheetwidth 0 inch translate	% new coordinates system origin
	      90 rotate				% landscape format
	      paper_adjust neg 0 translate
	    } if
	} if
      noborder not { printborder } if
      noheader not { printheader } if
      nofooter not { printfooter } if
      nopunchmark not { punchmark } if
	 upperx sheetside get  bodymargin  add
	    uppery
	    bodymargin bodyfontsize add  noheader {0} {headersize} ifelse  add
	 sub
      moveto
    } bind def

% Function printheader: prints page header.
/printheader
    { upperx sheetside get  uppery headersize sub 1 add  moveto
      datefont setfont
      gsave
        datefontsize headermargin rmoveto
	date show					% date/hour
      grestore
      gsave
	pagenum pnum cvs pop
	   pagewidth pagenumwidth sub
	   headermargin
	rmoveto
        (Page ) show pnum show				% page number
      grestore
      empty pnum copy pop
      gsave
        filenamefont setfont
	      filenameroom fname stringwidth pop sub 2 div datewidth add
	      filenamefontsize 2 mul 
	   add 
	   headermargin
	rmoveto
        fname show						% file name
      grestore
    } bind def

% Function printfooter: prints page footer.
/printfooter
    { upperx 0 get sheetnumbery moveto
      footerfont setfont
      fname show
    } bind def

% Function printborder: prints border page.
/printborder 
    { upperx sheetside get uppery moveto
      gsave					% print the four sides
        pagewidth 0 rlineto			% of the square
        0 pageheight neg rlineto
        pagewidth neg 0 rlineto
        closepath stroke
      grestore
      noheader not
         { 0 headersize neg rmoveto pagewidth 0 rlineto stroke }
      if
    } bind def

% Punch Marker
/punchmark {
  gsave
    newpath punchx punchy moveto
    punchx 2 add punchy -0.5 add lineto
    punchx 2 add punchy 0.5 add lineto
    punchx punchy lineto
    closepath
    0 setgray .8 setlinewidth stroke
  grestore
  } bind def

%
% Function endpage: adds a sheet number to the page (footnote) and prints
% the formatted page (physical impression). Activated at the end of each
% source page (lines reached or FF character).
/endpage
   { twinpage  sheetside 0 eq  and
        { /sheetside 1 def }
        { printpage }
     ifelse
   } bind def

% Function sheetnumber: prints the sheet number.
/sheetnumber
    { sheetnumberx sheetnumbery moveto
      datefont setfont
      sheet pnum cvs
	 dup stringwidth pop (0) stringwidth pop sub neg 0 rmoveto show
      empty pnum copy pop
    } bind def

% Function bs: go back one character width to emulate BS
/bs { backspacewidth neg 0 rmoveto } bind def

% Function s: print a source string
/s  { fontarray fonttype get setfont
      show
    } bind def

% Function ks: print a kanji source string
/ks { kfontarray fonttype get setfont
      KanjiRomanDiffHalf 0 rmoveto
      KanjiRomanDiff 0 3 -1 roll ashow
      KanjiRomanDiffHalf neg 0 rmoveto
    } def

% Function bl: beginning of line
/bl { gsave } bind def

% Function nl: newline
/nl {
      grestore
      0 bodyfontsize 1.1 mul neg rmoveto
    } bind def

% Function cr: carriage return
/cr { grestore } bind def

% Function hlr: half-line up
/hlr { 0 bodyfontsize 0.55 mul rmoveto } bind def

% Function hlr: half-line down
/hlf { 0 bodyfontsize 0.55 mul neg rmoveto } bind def

% Function hlr: half-character backward
/hcr { backspacewidth 2 div neg 0 rmoveto } bind def

% Function hlr: half-character forward
/hcf { backspacewidth 2 div 0 rmoveto } bind def

/R { /fonttype 0 def } bind def
/B { /fonttype 1 def } bind def
/I { /fonttype 2 def } bind def
R
/docsave save def
kanji_init
%%% -------------------------------------
%%% following lines are manually deleted 
%%% startdoc
%%% %%EndProlog
%%% 
%%% (stdin) newfile
%%% /sheet 1 def
%%% %%Page: 1 1
%%% 1 startpage
%%% bl ( ) s kanji_init (F#) ks nl
%%% 
%%% endpage
%%% 
%%% %%Trailer
%%% cleanup
%%% docsave restore end
%%% 
%-------------------------------------------
% end a2ps output 

ENDPSENDPS
%-------------------------------------------
% ここから下は単なる説明。
%
%                           藤 = サ + 滕
% ・・・・　　　・・・・
% ・・・・　　○・・●・     ●: 第一打鍵
% ・・・・　　　・・・・     ○: 第二打鍵
%   ( 8,1 ) -> ( 5,1 )
%  oneChar を呼出す時の座標系は
%  wx = 8, wy = 1, bx = 5, by = 1
%


%    【論理位置】
%     +<------------>+  $right = 5 ( logical,固定)
%     0  1  2  3  4  5  6  7  8  9  <- logical location
% 3
% 2   ・ ・ ・ ・　 　　・ ・ ・ ・
% 1   ・ ・ ・ ・　　○ ・ ・ ● ・     ●: 第一打鍵
% 0   ・ ・ ・ ・　　　 ・ ・ ・ ・     ○: 第二打鍵

%     【物理 = 印刷位置】
%     0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18
% 3                
% 2   ・ ・ ・ ・　                 　・ ・ ・ ・
% 1   ・ ・ ・ ・               　 ○ ・ ・ ● ・     ●: 第一打鍵
% 0   ・ ・ ・ ・              　　　 ・ ・ ・ ・     ○: 第二打鍵
%     +<--------->+ $kanjiOffset = 4
%                    +<------------>+ $rightOffset = 5
%     +<------------------------------------------->+ $nextChar = 15.5
Local Variables:
outline-regexp: "^[ 	]*sub\\s-+\\([-[:alnum:]+_:]+\\)\\|^\\(?:my\\|our\\)\\s-+\\([$@%][-[:alnum:]+_:]+\\)\\s-*=\\|^[ 	]*package\\s-+\\([-[:alnum:]+_:]+\\);\\|^=head[0-9][ 	]+\\(.*\\)\\|^=cut\\>\\|^Local \\|^/\\|%!"
End:
